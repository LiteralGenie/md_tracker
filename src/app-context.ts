import { ConfigOut, loadConfig } from "@/lib/config"
import { initMdb, Mdb, MdbSchema } from "@/lib/db"
import { MdTitlesSeen } from "@/lib/md/fetch-titles-seen"
import { findMdToken } from "@/lib/md/md-utils"
import { startDbReplication } from "@/lib/replication/replicate-db"
import { BehaviorSubject } from "@/lib/rx/behavior-subject"
import {
    exportLocalHistory,
    importRemoteHistory,
} from "@/lib/sync-md-history"
import { findKvSession, KvSession } from "@/lib/utils/kv-utils"
import { sleep } from "radash"

export interface AppContext {
    mdb: Mdb
    config: ConfigOut

    kv: null | {
        session: KvSession
    }

    mdToken$: BehaviorSubject<string | null>

    data: {
        chapterHistory$: BehaviorSubject<
            Map<
                MdbSchema["chapter_history"]["key"],
                MdbSchema["chapter_history"]["value"]
            >
        >
        titlesSeen$: null | BehaviorSubject<MdTitlesSeen>
    }

    app_log: typeof APP_LOG
}

export async function initAppContext(): Promise<AppContext> {
    startMdStorageMonitorTask(500)

    const mdb = await initMdb()
    const config = await loadConfig(mdb)

    const mdToken$ = monitorMdToken()

    let kv = null
    let session = await findKvSession(mdb)
    if (session) {
        kv = {
            session,
        }
    }

    const chapterHistory$ = await monitorChapterHistory(mdb)

    if (config.syncServerUrl) {
        startDbReplication(mdb, config.syncServerUrl)
    }

    hookConsole()

    return {
        mdb,
        config,
        kv,
        mdToken$,
        data: {
            chapterHistory$,
            titlesSeen$: null,
        },
        app_log: APP_LOG,
    }
}

function monitorMdToken() {
    const mdToken$ = new BehaviorSubject(
        null
    ) as AppContext["mdToken$"]

    const updateToken = () => {
        console.log("Updating md token")
        mdToken$.set(findMdToken())
    }

    addEventListener("storage", async (ev) => {
        if (ev.key !== "md") {
            return
        }
        updateToken()
    })

    updateToken()

    return mdToken$
}

/**
 * Watch MD's localstorage entry for changes
 * @param intervalMs
 */
async function startMdStorageMonitorTask(intervalMs: number) {
    let currValue = localStorage.getItem("md")
    while (true) {
        await sleep(intervalMs)
        const newValue = localStorage.getItem("md")
        if (newValue !== currValue) {
            currValue = newValue
            dispatchEvent(
                new StorageEvent("storage", {
                    key: "md",
                })
            )
        }
    }
}

async function monitorChapterHistory(mdb: Mdb) {
    // Sync reading history generated by MD in localstorage
    // with our own list in IndexedDB (which may be updated by other clients via sync server)
    await exportLocalHistory(mdb)
    const chapterHistory = await importRemoteHistory(mdb)
    const chapterHistory$ = new BehaviorSubject(
        new Map(chapterHistory.map((x) => [x.id, x] as const))
    )

    addEventListener("storage", async (ev) => {
        if (ev.key !== "md") {
            return
        }

        await exportLocalHistory(mdb)
    })

    addEventListener("dbchange", (ev) => {
        for (let c of ev.changes) {
            if (c.store !== "chapter_history") {
                continue
            }

            switch (c.op.type) {
                case "add":
                case "put":
                    chapterHistory$.value.set(
                        c.op.value.id,
                        c.op.value
                    )
                    break
                case "delete":
                    chapterHistory$.value.delete(c.op.key)
                    break
                case "clear":
                    chapterHistory$.value.clear()
                    break
            }
        }
    })

    return chapterHistory$
}

export const APP_LOG = [] as string[]
function hookConsole() {
    const oldDebug = console.debug
    console.debug = (...args) => {
        oldDebug(...args)
        APP_LOG.push(toLine("DEBUG", args))
    }

    const oldInfo = console.info
    console.info = (...args) => {
        oldInfo(...args)
        APP_LOG.push(toLine("INFO", args))
    }

    const oldLog = console.log
    console.log = (...args) => {
        oldLog(...args)
        APP_LOG.push(toLine("LOG", args))
    }

    const oldWarn = console.warn
    console.warn = (...args) => {
        oldWarn(...args)
        APP_LOG.push(toLine("WARN", args))
    }

    const oldError = console.error
    console.error = (...args) => {
        oldError(...args)
        APP_LOG.push(toLine("ERROR", args))
    }

    function toLine(level: string, args: any[]) {
        return [`[${level}]`.padStart(7), "-", ts(), "-", ...args]
            .map((x) => String(x))
            .join(" ")
    }

    function ts() {
        const now = new Date()
        const pad = (x: number, n = 2) =>
            x.toString().padStart(n, "0")

        return `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(
            now.getSeconds()
        )}.${pad(now.getMilliseconds(), 3)}`
    }
}
