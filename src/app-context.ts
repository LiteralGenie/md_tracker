import { ConfigOut, loadConfig } from "@/lib/config"
import { initMdb, Mdb } from "@/lib/db"
import { startDbReplication } from "@/lib/replication/replicate-db"
import {
    exportLocalHistory,
    importRemoteHistory,
} from "@/lib/sync-md-history"
import { findKvSession, KvSession } from "@/lib/utils/kv-utils"
import {
    fetchMdSeenTitles,
    findMdToken,
    MdTitlesSeen,
} from "@/lib/utils/md-utils"

export interface AppContext {
    mdb: Mdb
    config: ConfigOut

    kv: null | {
        session: KvSession
    }

    md: null | {
        token: string

        // Preload these because they're expensive to generate
        titlesSeen: MdTitlesSeen
        titlesSeenTask: Promise<unknown>
    }

    historySyncTask: Promise<unknown>

    app_log: typeof APP_LOG
}

export async function initAppContext(): Promise<AppContext> {
    const mdb = await initMdb()
    const config = await loadConfig(mdb)

    if (config.syncServerUrl) {
        await startDbReplication(mdb, config.syncServerUrl)
    }

    const mdToken = findMdToken()
    let md = null
    if (mdToken) {
        // Mapping chapter id to title id can take a while,
        // so just make do with whatever's in cache
        // and run the update in background, letting it take effect next refresh
        const titlesSeen = await fetchMdSeenTitles({
            mdb,
            mdToken,
            onlyCache: true,
        })
        const titlesSeenTask = fetchMdSeenTitles({
            mdb,
            mdToken,
            onlyCache: false,
        })

        md = {
            token: mdToken,
            titlesSeen,
            titlesSeenTask,
        }
    }

    let kv = null
    let session = await findKvSession(mdb)
    if (session) {
        kv = {
            session,
        }
    }

    // Sync reading history generated by MD in localstorage
    // with our own list in IndexedDB (which may be updated by other clients via sync server)
    const historySyncTask = (async () => {
        await exportLocalHistory(mdb)
        await importRemoteHistory(mdb)
    })()

    hookConsole()

    return {
        mdb,
        config,
        kv,
        md,
        historySyncTask,
        app_log: APP_LOG,
    }
}

export const APP_LOG = [] as string[]
function hookConsole() {
    const oldDebug = console.debug
    console.debug = (...args) => {
        oldDebug(...args)
        APP_LOG.push(toLine("DEBUG", args))
    }

    const oldInfo = console.info
    console.info = (...args) => {
        oldInfo(...args)
        APP_LOG.push(toLine("INFO", args))
    }

    const oldLog = console.log
    console.log = (...args) => {
        oldLog(...args)
        APP_LOG.push(toLine("LOG", args))
    }

    const oldWarn = console.warn
    console.warn = (...args) => {
        oldWarn(...args)
        APP_LOG.push(toLine("WARN", args))
    }

    const oldError = console.error
    console.error = (...args) => {
        oldError(...args)
        APP_LOG.push(toLine("ERROR", args))
    }

    function toLine(level: string, args: any[]) {
        return [`[${level}]`.padStart(7), "-", ts(), "-", ...args]
            .map((x) => String(x))
            .join(" ")
    }

    function ts() {
        const now = new Date()
        const pad = (x: number, n = 2) =>
            x.toString().padStart(n, "0")

        return `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(
            now.getSeconds()
        )}.${pad(now.getMilliseconds(), 3)}`
    }
}
